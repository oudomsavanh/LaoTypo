<!DOCTYPE html>
<html lang="lo">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Cache Busting Headers v1.3.0 -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤‡ªÅ‡∫°‡ªà‡∫ô‡∫Ñ‡∫ª‡∫ô‡∫•‡∫≤‡∫ß‡∫à‡∫£‡∫¥‡∫á ‡∫´‡∫º‡∫∑ ‡∫•‡∫≤‡∫ß‡∫≠‡∫µ‡ªà‡∫´‡∫•‡∫µ?</title>
    
    <!-- PWA Meta Tags -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#e2b714">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="LaoTypo">
    <link rel="apple-touch-icon" href="/icon-192x192.png">
    
    <!-- Fonts and Styles -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Lao+Looped:wght@400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <!-- Firebase Configuration -->
    <script src="firebase-config.js"></script>
    <style>
        :root {
            --bg-color: #2c2e31;
            --main-color: #e2b714;
            --sub-color: #646669;
            --text-color: #d1d0c5;
            --error-color: #ca4754;
            --correct-color: #72b483;
            --warning-color: #f59e0b;
        }
        body {
            font-family: 'Noto Sans Lao Looped', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 1rem;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .game-container {
            width: 100%;
            max-width: 900px;
            padding: 2rem;
            text-align: center;
        }
        .screen {
            display: none;
        }
        .screen.active {
            display: block;
        }
        .btn {
            background-color: var(--main-color);
            color: var(--bg-color);
            border: none;
            border-radius: 0.75rem;
            padding: 0.75rem 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 1rem;
        }
        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background-color: var(--sub-color);
            color: var(--text-color);
        }
        .btn-back {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: var(--sub-color);
            color: var(--text-color);
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
        }
        .btn-back:hover {
            background-color: var(--main-color);
            color: var(--bg-color);
        }
        .word-card {
            background-color: #3e4043;
            border: 2px solid #4a4d50;
            border-radius: 1rem;
            padding: 2rem;
            font-size: 1.75rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            min-height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .word-card:hover {
            border-color: var(--main-color);
            transform: scale(1.02);
        }
        .word-card.focused {
            border-color: var(--main-color);
            box-shadow: 0 0 0 3px rgba(226, 183, 20, 0.3);
        }
        .word-card.feedback-correct {
            background-color: var(--correct-color);
            border-color: var(--correct-color);
            color: white;
        }
        .word-card.feedback-incorrect {
            background-color: var(--error-color);
            border-color: var(--error-color);
            color: white;
        }
        .timer-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, var(--correct-color) 0%, var(--main-color) 50%, var(--error-color) 100%);
            border-radius: 1rem;
            transform-origin: left;
            transition: transform 0.1s linear;
        }
        
        /* Life Bar System Styles - v1.3.0 Update: Redesigned with CSS pixel hearts (black style), more compact design */
        .life-bar-header {
            background: linear-gradient(135deg, #3e4043 0%, #2c2e31 100%);
            border: 2px solid var(--main-color);
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .life-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            margin-bottom: 0.25rem;
        }
        
        .hearts {
            display: flex;
            gap: 0.5rem;
        }
        
        .heart {
            width: 24px;
            height: 24px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        /* CSS Pixel Heart - Simplified Design */
        .heart::before {
            content: '‚ù§Ô∏è';
            position: absolute;
            font-size: 20px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            filter: brightness(0) saturate(100%);
        }
        
        .heart.active {
            animation: heartPulse 3s infinite;
        }
        
        .heart.active::before {
            content: '‚ù§Ô∏è';
            filter: brightness(0) saturate(100%);
        }
        
        .heart.lost::before {
            content: '‚ù§Ô∏è';
            filter: brightness(0) saturate(100%) opacity(0.3);
        }
        
        .heart.lost {
            opacity: 0.4;
            transform: scale(0.8);
        }
        
        .heart.losing {
            animation: heartBreak 0.6s ease-in-out forwards;
        }
        
        @keyframes heartPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        @keyframes heartBreak {
            0% { transform: scale(1); }
            25% { transform: scale(1.2) rotate(5deg); }
            50% { transform: scale(1.3) rotate(-5deg); }
            75% { transform: scale(0.9) rotate(2deg); opacity: 0.7; }
            100% { transform: scale(0.8); opacity: 0.4; }
        }
        
        @keyframes lifeBarFlash {
            0%, 100% { background: linear-gradient(135deg, #3e4043 0%, #2c2e31 100%); }
            50% { background: linear-gradient(135deg, #ca4754 0%, #8b2635 100%); }
        }
        
        .motivation-text {
            font-size: 0.875rem;
            color: var(--sub-color);
            font-style: italic;
            font-weight: 500;
        }
        
        .life-text {
            font-weight: bold;
            color: var(--main-color);
            font-size: 1.1rem;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- Back Button -->
        <button id="back-to-menu-btn" class="btn-back">‚Üê ‡∫Å‡∫±‡∫ö‡ªÑ‡∫õ‡∫ó‡∫µ‡ªà‡ªú‡ªâ‡∫≤‡∫´‡∫º‡∫±‡∫Å</button>

        <!-- Game Screen -->
        <div id="game-screen" class="screen active">
            <!-- Word Loading Status -->
            <div id="word-loading-status" class="text-center mb-4 text-main-color">
                ‡∫Å‡∫≥‡∫•‡∫±‡∫á‡ªÇ‡∫´‡∫º‡∫î‡∫Ñ‡∫≥‡∫™‡∫±‡∫ö‡∫à‡∫≤‡∫Å Google Sheets...
            </div>
            
            <!-- Life Bar System -->
            <div class="life-bar-header mb-6">
                <div class="life-container">
                    <span class="life-text">‡∫ä‡∫¥‡∫ß‡∫¥‡∫î:</span>
                    <div class="hearts">
                        <span class="heart active"></span>
                        <span class="heart active"></span>
                        <span class="heart active"></span>
                    </div>
                </div>
                <div class="motivation-text">‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤‡∫°‡∫µ 3 ‡∫ä‡∫µ‡∫ß‡∫¥‡∫î, ‡∫à‡∫ª‡ªà‡∫á‡ªÉ‡∫ä‡ªâ‡ªÉ‡∫´‡ªâ‡∫Ñ‡∫∏‡ªâ‡∫°‡∫Ñ‡ªà‡∫≤‡∫ó‡∫µ‡ªà‡∫™‡∫∏‡∫î</div>
            </div>
            
            <!-- Player Name Header -->
            <div class="text-center mb-4">
                <h2 class="text-3xl font-bold text-main-color">‡∫ó‡ªà‡∫≤‡∫ô‡∫ú‡∫π‡ªâ‡∫´‡∫º‡∫¥‡ªâ‡∫ô: <span id="game-player-name"></span></h2>
                <div class="text-sm text-sub-color mt-1">
                    <span id="game-settings-display">‡∫•‡∫∞‡∫î‡∫±‡∫ö‡∫Ñ‡∫≥‡∫™‡∫±‡∫ö: ‡∫á‡ªà‡∫≤‡∫ç | ‡∫à‡∫≥‡∫Å‡∫±‡∫î‡ªÄ‡∫ß‡∫•‡∫≤: ‡∫õ‡∫¥‡∫î</span>
                </div>
            </div>
            
            <div class="flex justify-between items-center mb-6 text-xl">
                <div class="text-sub-color">‡∫ï‡∫≠‡∫ö‡∫ñ‡∫∑‡∫Å: <span id="current-streak" class="text-text-color font-bold">0</span></div>
                <div class="text-sub-color">‡∫Ñ‡∫∞‡ªÅ‡∫ô‡∫ô‡∫ó‡∫µ‡ªà‡∫î‡∫µ‡∫ó‡∫µ‡ªà‡∫™‡∫∏‡∫î: <span id="best-streak" class="text-text-color font-bold">0</span></div>
            </div>
            <div id="timer-container" class="h-2 mb-6">
                <div id="timer-bar" class="timer-bar"></div>
            </div>
            
            <!-- Context display area for showing word from Google Sheets Column A -->
            <div class="mb-6 text-center">
                <h3 class="text-xl text-sub-color mb-2">‡∫Ñ‡∫≥‡∫™‡∫±‡∫ö‡∫ó‡∫µ‡ªà‡∫ï‡ªâ‡∫≠‡∫á‡∫ï‡∫≠‡∫ö:</h3>
                <div id="context-display" class="text-4xl font-bold text-text-color bg-[#3e4043] rounded-lg py-4 px-6 min-h-[100px] flex items-center justify-center"></div>
            </div>
            
            <!-- Difficulty level display with color coding -->
            <div class="mb-4 text-center">
                <span class="text-sub-color">‡∫•‡∫∞‡∫î‡∫±‡∫ö‡∫Ñ‡∫ß‡∫≤‡∫°‡∫ç‡∫≤‡∫Å: </span>
                <span id="difficulty-display" class="font-bold"></span>
            </div>
            
            <div id="word-area" class="grid grid-cols-2 gap-4 md:gap-8 mb-8">
                <div id="word-card-left" class="word-card"></div>
                <div id="word-card-right" class="word-card"></div>
            </div>
            <p class="text-sub-color">‡ªÉ‡∫ä‡ªâ <kbd class="border-b-2 border-sub-color">A</kbd> ‡∫™‡∫≥‡∫•‡∫±‡∫ö‡∫ä‡ªâ‡∫≤‡∫ç, <kbd class="border-b-2 border-sub-color">D</kbd> ‡∫™‡∫≥‡∫•‡∫±‡∫ö‡∫Ç‡∫ß‡∫≤.</p>
        </div>

                 <!-- Results Screen -->
         <div id="results-screen" class="screen space-y-6">
             <h2 class="text-4xl font-bold text-main-color">‡∫ú‡∫ª‡∫ô‡∫Å‡∫≤‡∫ô‡∫õ‡∫∞‡ªÄ‡∫°‡∫µ‡∫ô ‡∫ö‡∫≠‡∫Å‡∫ß‡ªà‡∫≤...</h2>
             
             <!-- Game Stats -->
             <div class="bg-[#3e4043] rounded-lg p-6 space-y-4">
                 <div class="text-2xl space-y-2">
                     <p>‡∫Ñ‡∫∞‡ªÅ‡∫ô‡∫ô‡∫™‡∫∏‡∫î‡∫ó‡ªâ‡∫≤‡∫ç: <span id="final-streak" class="text-main-color font-bold">0</span></p>
                     <p>‡∫Ñ‡∫ß‡∫≤‡∫°‡ªÅ‡∫°‡ªà‡∫ô‡∫ç‡∫≥: <span id="accuracy-stat" class="text-main-color font-bold">0%</span></p>
                 </div>
                 <div id="evaluation-result" class="text-xl font-bold"></div>
                 
                 <!-- Personal Best Indicator -->
                 <div id="personal-best-indicator" class="hidden bg-gradient-to-r from-yellow-400 to-orange-500 text-black px-4 py-2 rounded-lg font-bold text-center">
                     üèÜ ‡∫™‡∫∞‡∫ñ‡∫¥‡∫ï‡∫¥‡ªÉ‡ªù‡ªà‡∫Ç‡∫≠‡∫á‡∫ó‡ªà‡∫≤‡∫ô‡ªÄ‡∫≠‡∫á‡∫á‡∫á! üèÜ
                 </div>
             </div>

             <!-- Personal Records -->
             <div class="bg-[#3e4043] rounded-lg p-6">
                 <h3 class="text-xl font-bold text-main-color mb-4 text-center">üìä ‡∫™‡∫∞‡∫ñ‡∫¥‡∫ï‡∫¥‡∫Ç‡∫≠‡∫á‡∫ó‡ªà‡∫≤‡∫ô</h3>
                 <div class="grid grid-cols-3 gap-4 text-sm">
                     <div class="text-center">
                         <div class="text-correct-color font-bold">‡∫á‡ªà‡∫≤‡∫ç</div>
                         <div id="easy-best-score" class="text-lg">0</div>
                         <div id="easy-best-accuracy" class="text-sub-color">0%</div>
                         <div id="easy-games-count" class="text-xs text-sub-color">0 games</div>
                     </div>
                     <div class="text-center">
                         <div class="text-main-color font-bold">‡∫õ‡∫≤‡∫ô‡∫Å‡∫≤‡∫á</div>
                         <div id="medium-best-score" class="text-lg">0</div>
                         <div id="medium-best-accuracy" class="text-sub-color">0%</div>
                         <div id="medium-games-count" class="text-xs text-sub-color">0 games</div>
                     </div>
                     <div class="text-center">
                         <div class="text-error-color font-bold">‡∫ç‡∫≤‡∫Å</div>
                         <div id="hard-best-score" class="text-lg">0</div>
                         <div id="hard-best-accuracy" class="text-sub-color">0%</div>
                         <div id="hard-games-count" class="text-xs text-sub-color">0 games</div>
                     </div>
                 </div>
             </div>

             <!-- Global Ranking Preview -->
             <div class="bg-[#3e4043] rounded-lg p-6">
                 <h3 class="text-xl font-bold text-main-color mb-4 text-center">üåç ‡∫≠‡∫±‡∫ô‡∫î‡∫±‡∫ö‡∫õ‡∫∞‡ªÄ‡∫ó‡∫î</h3>
                 <div id="global-ranking-info" class="text-center text-sub-color">
                     <p id="global-rank-text">‡∫≠‡∫±‡∫ô‡∫î‡∫±‡∫ö‡∫Ç‡∫≠‡∫á‡∫ó‡ªà‡∫≤‡∫ô: ‡∫Å‡∫≥‡∫•‡∫±‡∫á‡∫õ‡∫∞‡ªÄ‡∫°‡∫µ‡∫ô‡∫ú‡∫ª‡∫ô...</p>
                     <p class="text-xs mt-2">üîÑ ‡∫Å‡∫∞‡∫î‡∫≤‡∫ô‡∫Å‡∫Ω‡∫î‡∫ï‡∫¥‡∫ç‡∫ª‡∫î‡ªÅ‡∫ö‡∫ö‡ªÄ‡∫ï‡∫±‡∫°‡ªÜ ‡∫à‡∫∞‡∫ï‡∫≤‡∫°‡∫°‡∫≤‡∫ó‡∫µ‡∫´‡∫º‡∫±‡∫á‡ªÄ‡∫î‡∫µ‡ªâ~ </p>
                 </div>
             </div>

             <!-- Action Buttons -->
             <div class="space-y-4">
                 <button onclick="playAgain()" class="btn text-xl px-8 py-3">‡∫´‡∫º‡∫¥‡ªâ‡∫ô‡∫≠‡∫µ‡∫Å‡∫Ñ‡∫±‡ªâ‡∫á</button>
                 <button onclick="backToMenu()" class="btn btn-secondary text-xl px-8 py-3">‡∫Å‡∫±‡∫ö‡ªÑ‡∫õ‡∫ó‡∫µ‡ªà‡ªÄ‡∫°‡∫ô‡∫π</button>
                 <button onclick="addWords()" class="btn text-xl px-8 py-3">‡∫ï‡∫∑‡ªà‡∫°‡∫Ñ‡∫≥‡∫™‡∫±‡∫ö</button>
             </div>
         </div>
        
        <!-- Footer -->
        <div class="absolute bottom-4 right-4 text-xs text-sub-color">
            <p>Game Mode</p>
            <p>Version: 1.5.0-Testing</p>
        </div>
    </div>

    <script>
        // Google Sheets CSV URL (same as testing.html)
        const GOOGLE_SHEETS_URL = 'https://docs.google.com/spreadsheets/d/1jhdIOg9aqy7Jb28pqnz9I5F23uQ8HYyABvvMxqSzGr0/export?format=csv&gid=0';

        // DOM Elements
        const currentStreakEl = document.getElementById('current-streak');
        const bestStreakEl = document.getElementById('best-streak');
        const wordCardLeft = document.getElementById('word-card-left');
        const wordCardRight = document.getElementById('word-card-right');
        const timerBar = document.getElementById('timer-bar');
        const contextDisplay = document.getElementById('context-display');
        const difficultyDisplay = document.getElementById('difficulty-display');
        const gamePlayerName = document.getElementById('game-player-name');
        const wordLoadingStatus = document.getElementById('word-loading-status');
        const gameSettingsDisplay = document.getElementById('game-settings-display');

        // Game State & Settings - Will be populated from URL parameters
        let userId = 'local_user_' + Math.random().toString(36).substr(2, 9);
        let currentStreak = 0;
        let currentEntry, correctAnswer, wrongAnswer, correctWordPosition;
        let timerInterval;
        let gameInProgress = false;
        let displayName = '';
        let wordList = [];
        
        // Life System
        let playerLives = 3;
        let maxLives = 3;
        let heartsContainer, motivationText;
        
        // Settings from URL parameters
        let settings = {
            difficulty: 'easy',
            timer: false,
            sound: true,
            music: false,
        };

                 let stats = {
             bestStreak: 0,
             totalGames: 0,
             totalCorrect: 0,
             totalMistakes: 0,
         };

         // MonkeyType-inspired Personal Records
         let personalRecords = {
             easy: { bestScore: 0, bestAccuracy: 0, gamesPlayed: 0, totalScore: 0 },
             medium: { bestScore: 0, bestAccuracy: 0, gamesPlayed: 0, totalScore: 0 },
             hard: { bestScore: 0, bestAccuracy: 0, gamesPlayed: 0, totalScore: 0 }
         };

         // Global Leaderboard (simulated for demo - would be real cloud in production)
         let globalLeaderboard = {
             easy: [],
             medium: [],
             hard: []
         };

        // Background Music System
        let backgroundMusic = null;
        
        function initializeBackgroundMusic() {
            backgroundMusic = document.createElement('audio');
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.3;
            backgroundMusic.preload = 'none';
            // backgroundMusic.src = 'background-music.wav';
        }
        
        function toggleBackgroundMusic() {
            if (!backgroundMusic) return;
            
            if (settings.music && backgroundMusic.src) {
                backgroundMusic.play().catch(e => console.log('Music play failed:', e));
            } else {
                backgroundMusic.pause();
            }
        }

        // Enhanced word loading from Google Sheets (copied from testing.html, no fallback)
        async function loadWordListsFromGoogleSheets() {
            try {
                wordLoadingStatus.textContent = '‡∫Å‡∫≥‡∫•‡∫±‡∫á‡ªÇ‡∫´‡∫º‡∫î‡∫Ñ‡∫≥‡∫™‡∫±‡∫ö‡∫à‡∫≤‡∫Å Google Sheets...';
                wordLoadingStatus.style.color = 'var(--main-color)';
                
                const response = await fetch(GOOGLE_SHEETS_URL);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const csvText = await response.text();
                const lines = csvText.split('\n');
                
                // Parse CSV data: A=context, B=correct, C=wrong, D=difficulty
                wordList = lines
                    .slice(1) // Skip header row (A1:D1)
                    .map(line => {
                        const columns = line.split(',').map(col => col.replace(/"/g, '').trim());
                        if (columns.length >= 4 && columns[0] && columns[1] && columns[2] && columns[3]) {
                            return {
                                context: columns[0],    // Column A - context to display
                                correct: columns[1],    // Column B - correct answer
                                wrong: columns[2],      // Column C - wrong answer
                                difficulty: parseInt(columns[3]) || 1  // Column D - difficulty (1=easy, 2=medium, 3=difficult)
                            };
                        }
                        return null;
                    })
                    .filter(item => item !== null); // Remove invalid entries
                
                console.log("Word list loaded from Google Sheets:", wordList.length, "entries");
                console.log("Sample entries:", wordList.slice(0, 3));
                
                if (wordList.length === 0) {
                    throw new Error("No valid entries found in the spreadsheet");
                }
                
                wordLoadingStatus.textContent = `‡ªÇ‡∫´‡∫º‡∫î‡∫™‡∫≥‡ªÄ‡∫•‡∫±‡∫î! ‡∫°‡∫µ ${wordList.length} ‡∫Ñ‡∫≥‡∫™‡∫±‡∫ö`;
                wordLoadingStatus.style.color = 'var(--correct-color)';
                
                // Hide loading status after successful load
                setTimeout(() => {
                    wordLoadingStatus.style.display = 'none';
                }, 2000);
                
            } catch (error) {
                console.error("Error loading word list from Google Sheets:", error);
                console.log("Error details:", error.message);
                console.log("Fetch URL:", GOOGLE_SHEETS_URL);
                
                wordLoadingStatus.textContent = '‡ªÇ‡∫´‡∫º‡∫î‡∫ú‡∫¥‡∫î‡∫û‡∫≤‡∫î! ‡ªÉ‡∫ä‡ªâ‡∫Ç‡ªç‡ªâ‡∫°‡∫π‡∫ô‡∫ó‡∫ª‡∫î‡∫™‡∫≠‡∫ö';
                wordLoadingStatus.style.color = 'var(--warning-color)';
                
                // Minimal fallback data for testing when Google Sheets fails
                wordList = [
                    { context: '‡∫™‡∫∞‡∫ö‡∫≤‡∫ç‡∫î‡∫µ', correct: '‡∫™‡∫∞‡∫ö‡∫≤‡∫ç‡∫î‡∫µ', wrong: '‡∫™‡∫∞‡∫ö‡∫≤‡∫ç‡∫î‡∫µ‡∫µ', difficulty: 1 },
                    { context: '‡∫Ç‡∫≠‡∫ö‡ªÉ‡∫à', correct: '‡∫Ç‡∫≠‡∫ö‡ªÉ‡∫à', wrong: '‡∫Ç‡∫≠‡∫ö‡∫à‡∫±‡∫ç', difficulty: 1 },
                    { context: '‡∫•‡∫≤‡∫ß', correct: '‡∫•‡∫≤‡∫ß', wrong: '‡∫•‡∫≤‡∫ç', difficulty: 1 },
                    { context: '‡∫û‡∫≤‡∫™‡∫≤‡∫•‡∫≤‡∫ß', correct: '‡∫û‡∫≤‡∫™‡∫≤‡∫•‡∫≤‡∫ß', wrong: '‡∫û‡∫≤‡∫™‡∫≤‡∫•‡∫≤‡∫ç', difficulty: 2 },
                    { context: '‡ªÇ‡∫Æ‡∫á‡∫Æ‡∫Ω‡∫ô', correct: '‡ªÇ‡∫Æ‡∫á‡∫Æ‡∫Ω‡∫ô', wrong: '‡ªÇ‡∫Æ‡∫á‡∫Æ‡∫¥‡∫Ω‡∫ô', difficulty: 2 },
                    { context: '‡∫õ‡∫∞‡ªÄ‡∫ó‡∫î‡∫•‡∫≤‡∫ß', correct: '‡∫õ‡∫∞‡ªÄ‡∫ó‡∫î‡∫•‡∫≤‡∫ß', wrong: '‡∫õ‡∫∞‡ªÄ‡∫ó‡∫î‡∫•‡∫≤‡∫ç', difficulty: 2 },
                    { context: '‡∫Ñ‡∫≠‡∫°‡∫û‡∫¥‡∫ß‡ªÄ‡∫ï‡∫µ', correct: '‡∫Ñ‡∫≠‡∫°‡∫û‡∫¥‡∫ß‡ªÄ‡∫ï‡∫µ', wrong: '‡∫Ñ‡∫≠‡∫°‡∫û‡∫¥‡∫ç‡ªÄ‡∫ï‡∫µ', difficulty: 3 },
                    { context: '‡∫ß‡∫¥‡∫ó‡∫∞‡∫ç‡∫≤‡∫™‡∫≤‡∫î', correct: '‡∫ß‡∫¥‡∫ó‡∫∞‡∫ç‡∫≤‡∫™‡∫≤‡∫î', wrong: '‡∫ß‡∫¥‡∫ó‡∫∞‡∫ç‡∫≤‡∫™‡∫≤‡∫ç', difficulty: 3 },
                    { context: '‡ªÄ‡∫ï‡∫±‡∫Å‡ªÇ‡∫ô‡ªÇ‡∫•‡∫ä‡∫µ', correct: '‡ªÄ‡∫ï‡∫±‡∫Å‡ªÇ‡∫ô‡ªÇ‡∫•‡∫ä‡∫µ', wrong: '‡ªÄ‡∫ï‡∫±‡∫Å‡ªÇ‡∫ô‡ªÇ‡∫•‡∫ä‡∫¥', difficulty: 3 }
                ];
                
                console.log("Using fallback word list for testing:", wordList.length, "entries");
                
                // Hide loading status after fallback load
                setTimeout(() => {
                    wordLoadingStatus.style.display = 'none';
                }, 3000);
            }
        }

        function getDifficultyLabel(level) {
            switch(level) {
                case 1: return { text: '‡∫á‡ªà‡∫≤‡∫ç', color: 'var(--correct-color)' };
                case 2: return { text: '‡∫õ‡∫≤‡∫ô‡∫Å‡∫≤‡∫á', color: 'var(--main-color)' };
                case 3: return { text: '‡∫ç‡∫≤‡∫Å', color: 'var(--error-color)' };
                default: return { text: '‡∫á‡ªà‡∫≤‡∫ç', color: 'var(--correct-color)' };
            }
        }

        function filterWordsByDifficulty(difficulty) {
            let targetLevel;
            switch(difficulty) {
                case 'easy': targetLevel = 1; break;
                case 'medium': targetLevel = 2; break;
                case 'hard': targetLevel = 3; break;
                default: targetLevel = 1;
            }
            
            const filtered = wordList.filter(entry => entry.difficulty === targetLevel);
            return filtered.length > 0 ? filtered : wordList;
        }

        // Life System Functions
        function updateLifeDisplay() {
            const hearts = heartsContainer.querySelectorAll('.heart');

            
            hearts.forEach((heart, index) => {
                if (index < playerLives) {
                    heart.classList.remove('lost');
                    heart.classList.add('active');
                } else {
                    heart.classList.add('lost');
                    heart.classList.remove('active');
                }
            });
            
            updateMotivationText();
        }

        function loseLife() {
            if (playerLives > 0) {
                playerLives--;
                
                const hearts = heartsContainer.querySelectorAll('.heart');
                const heartToBreak = hearts[playerLives];
                heartToBreak.classList.add('losing');
                
                setTimeout(() => {
                    heartToBreak.classList.remove('losing');
                    updateLifeDisplay();
                    
                    if (playerLives === 0) {
                        gameOver();
                    } else {
                        showLifeWarning();
                        setTimeout(nextRound, 1500);
                    }
                }, 600);
            }
        }

        function updateMotivationText() {
            switch(playerLives) {
                case 3:
                    motivationText.textContent = "You've got 3 lives‚Äîspend them wisely!";
                    motivationText.style.color = 'var(--correct-color)';
                    break;
                case 2:
                    motivationText.textContent = "Be careful! 2 lives remaining.";
                    motivationText.style.color = 'var(--main-color)';
                    break;
                case 1:
                    motivationText.textContent = "Last chance! Don't waste it!";
                    motivationText.style.color = 'var(--error-color)';
                    break;
                case 0:
                    // This case will use endGame() evaluation instead
                    break;
            }
        }

        function showLifeWarning() {
            const lifeBar = document.querySelector('.life-bar-header');
            lifeBar.style.animation = 'lifeBarFlash 0.5s ease-in-out 2';
            
            setTimeout(() => {
                lifeBar.style.animation = '';
            }, 1000);
        }

        function resetLives() {
            playerLives = maxLives;
            updateLifeDisplay();
        }

        function gameOver() {
            gameInProgress = false;
            clearInterval(timerInterval);
            
            // Show results screen with endGame() evaluation for case 0
            switchScreen('results');
            endGame();
        }

                 // Personal Records Functions
         function updatePersonalRecords() {
             const difficulty = settings.difficulty;
             const currentScore = currentStreak;
             const totalAnswers = currentStreak + stats.totalMistakes;
             const currentAccuracy = totalAnswers > 0 ? (currentStreak / totalAnswers) * 100 : 0;
             
             const record = personalRecords[difficulty];
             let isNewBest = false;
             
             // Update games played
             record.gamesPlayed++;
             record.totalScore += currentScore;
             
             // Check for new personal best score
             if (currentScore > record.bestScore) {
                 record.bestScore = currentScore;
                 isNewBest = true;
             }
             
             // Check for new personal best accuracy
             if (currentAccuracy > record.bestAccuracy) {
                 record.bestAccuracy = currentAccuracy;
                 isNewBest = true;
             }
             
             // Show personal best indicator
             if (isNewBest) {
                 document.getElementById('personal-best-indicator').classList.remove('hidden');
             }
             
             // Update global ranking simulation
             updateGlobalRanking(difficulty, currentScore, currentAccuracy);
             
             // Update UI display
             updatePersonalRecordsDisplay();
         }

         function updatePersonalRecordsDisplay() {
             // Update Easy records
             document.getElementById('easy-best-score').textContent = personalRecords.easy.bestScore;
             document.getElementById('easy-best-accuracy').textContent = `${personalRecords.easy.bestAccuracy.toFixed(1)}%`;
             document.getElementById('easy-games-count').textContent = `${personalRecords.easy.gamesPlayed} games`;
             
             // Update Medium records
             document.getElementById('medium-best-score').textContent = personalRecords.medium.bestScore;
             document.getElementById('medium-best-accuracy').textContent = `${personalRecords.medium.bestAccuracy.toFixed(1)}%`;
             document.getElementById('medium-games-count').textContent = `${personalRecords.medium.gamesPlayed} games`;
             
             // Update Hard records
             document.getElementById('hard-best-score').textContent = personalRecords.hard.bestScore;
             document.getElementById('hard-best-accuracy').textContent = `${personalRecords.hard.bestAccuracy.toFixed(1)}%`;
             document.getElementById('hard-games-count').textContent = `${personalRecords.hard.gamesPlayed} games`;
         }

         function updateGlobalRanking(difficulty, score, accuracy) {
             // Simulated global ranking - in production this would be cloud-based
             const playerEntry = { name: displayName, score: score, accuracy: accuracy, timestamp: Date.now() };
             
             // Add to leaderboard
             globalLeaderboard[difficulty].push(playerEntry);
             
             // Sort by score descending, then by accuracy
             globalLeaderboard[difficulty].sort((a, b) => {
                 if (b.score !== a.score) return b.score - a.score;
                 return b.accuracy - a.accuracy;
             });
             
             // Keep only top 100
             globalLeaderboard[difficulty] = globalLeaderboard[difficulty].slice(0, 100);
             
             // Find player's rank
             const playerRank = globalLeaderboard[difficulty].findIndex(entry => 
                 entry.name === displayName && entry.timestamp === playerEntry.timestamp
             ) + 1;
             
             // Update ranking display
             const totalPlayers = Math.max(playerRank, Math.floor(Math.random() * 1000) + 500); // Simulated total
             document.getElementById('global-rank-text').textContent = 
                 `Your rank: #${playerRank} of ${totalPlayers} players`;
         }

         // Local Storage Functions
         function loadUserData() {
             try {
                 const savedData = localStorage.getItem('laoTypoGame_userData');
                 if (savedData) {
                     const data = JSON.parse(savedData);
                     stats = { ...stats, ...data.stats };
                     personalRecords = { ...personalRecords, ...data.personalRecords };
                     globalLeaderboard = { ...globalLeaderboard, ...data.globalLeaderboard };
                     displayName = data.displayName || '';
                 }
             } catch (error) {
                 console.error("Error loading user data:", error);
             }
         }

         function saveUserData() {
             try {
                 const userData = {
                     settings,
                     stats,
                     personalRecords,
                     globalLeaderboard,
                     displayName,
                     lastPlayed: new Date().toISOString()
                 };
                 localStorage.setItem('laoTypoGame_userData', JSON.stringify(userData));
             } catch (error) {
                 console.error("Error saving user data:", error);
             }
         }

        // Game Functions
        function switchScreen(screenName) {
            const screens = {
                game: document.getElementById('game-screen'),
                results: document.getElementById('results-screen')
            };
            Object.values(screens).forEach(s => s.classList.remove('active'));
            if (screens[screenName]) screens[screenName].classList.add('active');
        }

                 function nextRound() {
             console.log('üéÆ Starting new round with difficulty:', settings.difficulty);
             
             currentStreakEl.textContent = currentStreak;
             bestStreakEl.textContent = stats.bestStreak;
             wordCardLeft.classList.remove('feedback-correct', 'feedback-incorrect', 'focused');
             wordCardRight.classList.remove('feedback-correct', 'feedback-incorrect', 'focused');
             
             // Get words filtered by selected difficulty
             const availableWords = filterWordsByDifficulty(settings.difficulty);
             console.log(`üìö Available words for ${settings.difficulty}:`, availableWords.length);
             
             if (availableWords.length === 0) {
                 console.error('‚ùå No words available for difficulty:', settings.difficulty);
                 alert(`‡∫ö‡ªç‡ªà‡∫°‡∫µ‡∫Ñ‡∫≥‡∫™‡∫±‡∫ö‡∫™‡∫≥‡∫•‡∫±‡∫ö‡∫•‡∫∞‡∫î‡∫±‡∫ö ${settings.difficulty}!`);
                 return;
             }
             
             currentEntry = availableWords[Math.floor(Math.random() * availableWords.length)];
             console.log('üéØ Selected word:', currentEntry);
             
             contextDisplay.textContent = currentEntry.context;
             
             const difficultyInfo = getDifficultyLabel(currentEntry.difficulty);
             difficultyDisplay.textContent = difficultyInfo.text;
             difficultyDisplay.style.color = difficultyInfo.color;
             
             correctAnswer = currentEntry.correct;
             wrongAnswer = currentEntry.wrong;

             correctWordPosition = Math.random() < 0.5 ? 'left' : 'right';

             if (correctWordPosition === 'left') {
                 wordCardLeft.textContent = correctAnswer;
                 wordCardRight.textContent = wrongAnswer;
                 console.log('üéØ Correct answer on LEFT:', correctAnswer);
             } else {
                 wordCardLeft.textContent = wrongAnswer;
                 wordCardRight.textContent = correctAnswer;
                 console.log('üéØ Correct answer on RIGHT:', correctAnswer);
             }
             
             startTimer();
         }

        function handleSelection(selectedPosition) {
            if (!gameInProgress) return;
            clearInterval(timerInterval);
            const isCorrect = selectedPosition === correctWordPosition;
            const selectedCard = selectedPosition === 'left' ? wordCardLeft : wordCardRight;

            if (isCorrect) {
                playSound('correct');
                selectedCard.classList.add('feedback-correct');
                currentStreak++;
                if (currentStreak > stats.bestStreak) {
                    stats.bestStreak = currentStreak;
                }
                setTimeout(nextRound, 400);
            } else {
                playSound('incorrect');
                selectedCard.classList.add('feedback-incorrect');
                stats.totalMistakes += 1;
                
                loseLife();
            }
        }

                 function endGame() {
             gameInProgress = false;
             stats.totalCorrect += currentStreak;
             stats.totalGames++;

             document.getElementById('final-streak').textContent = currentStreak;
             
             // Calculate accuracy (avoid division by zero)
             const totalAnswers = currentStreak + stats.totalMistakes;
             const sessionAccuracy = totalAnswers > 0 ? (currentStreak / totalAnswers) * 100 : 0;
             document.getElementById('accuracy-stat').textContent = `${sessionAccuracy.toFixed(1)}%`;
             
             const evaluationEl = document.getElementById('evaluation-result');
             
             // Case 0: Game Over (lost all lives) - Use endGame evaluation
             if (playerLives === 0) {
                 if (currentStreak === 0) {
                     evaluationEl.textContent = "‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤‡ªÄ‡∫õ‡∫±‡∫ô‡∫Ñ‡∫ª‡∫ô‡∫ï‡ªà‡∫≤‡∫á‡∫õ‡∫∞‡ªÄ‡∫ó‡∫î ‡∫ó‡∫µ‡ªà‡∫ï‡∫ª‡∫Åüõ©";
                     evaluationEl.style.color = 'var(--error-color)';
                 } else if (currentStreak < 5) {
                     evaluationEl.textContent = "‡∫¢‡ªà‡∫≤‡∫á‡ªú‡ªâ‡∫≠‡∫ç‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤‡∫Å‡ªç‡∫ö‡ªç‡ªà‡ªÅ‡∫°‡ªà‡∫ô‡∫Ñ‡∫ª‡∫ô '‡∫à‡∫£‡∫¥‡∫á‡ªÉ‡∫à'";
                     evaluationEl.style.color = 'var(--warning-color)';
                 } else if (currentStreak < 10) {
                     evaluationEl.textContent = "‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤‡ªÄ‡∫Å‡∫µ‡∫î‡∫¢‡∫π‡ªà‡∫•‡∫≤‡∫ß ‡ªÅ‡∫ï‡ªà‡ªÑ‡∫õ‡ªÉ‡∫´‡∫ç‡ªà‡∫¢‡∫π‡ªà‡∫ï‡ªà‡∫≤‡∫á‡∫õ‡∫∞‡ªÄ‡∫ó‡∫î";
                     evaluationEl.style.color = 'var(--main-color)';
                 } else if (currentStreak < 15) {
                     evaluationEl.textContent = "‡∫•‡∫π‡∫Å‡∫ä‡∫≠‡∫î‡∫•‡∫≤‡∫ß";
                     evaluationEl.style.color = 'var(--main-color)';
                 } else {
                     evaluationEl.textContent = "‡∫ä‡∫≤‡∫î‡∫Å‡ªà‡∫≠‡∫ô‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤‡ªÄ‡∫Å‡∫µ‡∫î‡ªÄ‡∫õ‡∫±‡∫ô‡∫Ñ‡∫ª‡∫ô‡∫•‡∫≤‡∫ß ‡∫ä‡∫≤‡∫î‡∫ô‡∫µ‡ªâ‡∫Å‡ªç‡ªÄ‡∫ä‡∫±‡ªà‡∫ô‡∫Å‡∫±‡∫ô"; 
                     evaluationEl.style.color = 'var(--correct-color)'; 
                 }
             } else {
                 // Manual quit or timer end - standard accuracy evaluation
                 if (sessionAccuracy < 30) {
                     evaluationEl.textContent = "‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤‡ªÄ‡∫õ‡∫±‡∫ô‡∫Ñ‡∫ª‡∫ô‡∫ï‡ªà‡∫≤‡∫á‡∫õ‡∫∞‡ªÄ‡∫ó‡∫î ‡∫ó‡∫µ‡ªà‡∫ï‡∫ª‡∫Åüõ©";
                     evaluationEl.style.color = 'var(--error-color)';
                 } else if (sessionAccuracy < 50) {
                     evaluationEl.textContent = "‡∫¢‡ªà‡∫≤‡∫á‡ªú‡ªâ‡∫≠‡∫ç‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤‡∫Å‡ªç‡∫ö‡ªç‡ªà‡ªÅ‡∫°‡ªà‡∫ô‡∫Ñ‡∫ª‡∫ô '‡∫à‡∫£‡∫¥‡∫á‡ªÉ‡∫à'";
                     evaluationEl.style.color = 'var(--warning-color)';
                 } else if (sessionAccuracy < 70) {
                     evaluationEl.textContent = "‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤‡ªÄ‡∫Å‡∫µ‡∫î‡∫¢‡∫π‡ªà‡∫•‡∫≤‡∫ß ‡ªÅ‡∫ï‡ªà‡ªÑ‡∫õ‡ªÉ‡∫´‡∫ç‡ªà‡∫¢‡∫π‡ªà‡∫ï‡ªà‡∫≤‡∫á‡∫õ‡∫∞‡ªÄ‡∫ó‡∫î";
                     evaluationEl.style.color = 'var(--main-color)';
                 } else if (sessionAccuracy < 85) {
                     evaluationEl.textContent = "‡∫•‡∫π‡∫Å‡∫ä‡∫≠‡∫î‡∫•‡∫≤‡∫ß";
                     evaluationEl.style.color = 'var(--main-color)';
                 } else {
                     evaluationEl.textContent = "‡∫ä‡∫≤‡∫î‡∫Å‡ªà‡∫≠‡∫ô‡ªÄ‡∫à‡∫ª‡ªâ‡∫≤‡ªÄ‡∫Å‡∫µ‡∫î‡ªÄ‡∫õ‡∫±‡∫ô‡∫Ñ‡∫ª‡∫ô‡∫•‡∫≤‡∫ß ‡∫ä‡∫≤‡∫î‡∫ô‡∫µ‡ªâ‡∫Å‡ªç‡ªÄ‡∫ä‡∫±‡ªà‡∫ô‡∫Å‡∫±‡∫ô"; 
                     evaluationEl.style.color = 'var(--correct-color)'; 
                 }
             }

             // Update personal records
             updatePersonalRecords();
             saveUserData();
         }

                 function startTimer() {
             if (!settings.timer) {
                 console.log('‚è±Ô∏è Timer disabled, skipping countdown');
                 timerBar.style.transform = 'scaleX(0)';
                 return;
             }
             
             console.log('‚è±Ô∏è Starting 5-second timer...');
             let timeLeft = 5000; // 5 seconds
             const interval = 50; // Update every 50ms for smooth animation
             
             // Reset timer bar to full
             timerBar.style.transform = 'scaleX(1)';
             
             timerInterval = setInterval(() => {
                 timeLeft -= interval;
                 const percentage = Math.max(0, timeLeft / 5000);
                 timerBar.style.transform = `scaleX(${percentage})`;
                 
                 // Debug countdown
                 if (timeLeft % 1000 < interval) {
                     console.log(`‚è±Ô∏è Timer: ${Math.ceil(timeLeft / 1000)} seconds left`);
                 }
                 
                 if (timeLeft <= 0) {
                     clearInterval(timerInterval);
                     console.log('‚è±Ô∏è Timer expired! Auto-selecting wrong answer');
                     
                     // When timer expires, treat as wrong answer (lose life)
                     playSound('incorrect');
                     stats.totalMistakes += 1;
                     loseLife();
                 }
             }, interval);
         }

        function playSound(type) {
            if (!settings.sound) return;
            
            try {
                const synth = new Tone.Synth().toDestination();
                switch(type) {
                    case 'correct':
                        synth.triggerAttackRelease('C5', '0.1');
                        break;
                    case 'incorrect':
                        synth.triggerAttackRelease('C3', '0.3');
                        break;
                    case 'start':
                        synth.triggerAttackRelease('G4', '0.2');
                        break;
                }
            } catch (error) {
                console.log('Sound failed:', error);
            }
        }

                 // Navigation Functions
         function playAgain() {
             // Reset game state
             currentStreak = 0;
             stats.totalMistakes = 0; // Reset mistakes counter for new game
             gameInProgress = true;
             resetLives();
             
             // Hide personal best indicator
             document.getElementById('personal-best-indicator').classList.add('hidden');
             
             switchScreen('game');
             nextRound();
         }

        function backToMenu() {
            window.location.href = 'testing.html';
        }

        function addWords() {
            window.open('https://docs.google.com/forms/d/e/1FAIpQLSefITi3AKGdPc843ID2PffFaYei-O7oouF0XAAciiK3seA55Q/viewform', '_blank');
        }

        // Enhanced URL Parameter Functions with validation and debugging
        function getURLParameters() {
            console.log('üîó Reading URL parameters...');
            const urlParams = new URLSearchParams(window.location.search);
            console.log('üìã Raw URL params:', window.location.search);
            
            // Read and validate player name
            const playerParam = urlParams.get('player');
            displayName = playerParam ? decodeURIComponent(playerParam) : 'Anonymous Player';
            console.log('üë§ Player name:', displayName, '(from param:', playerParam, ')');
            
            // Read and validate difficulty
            const difficultyParam = urlParams.get('difficulty');
            const validDifficulties = ['easy', 'medium', 'hard'];
            settings.difficulty = validDifficulties.includes(difficultyParam) ? difficultyParam : 'easy';
            console.log('‚ö° Difficulty:', settings.difficulty, '(from param:', difficultyParam, ')');
            
            // Read boolean settings
            settings.timer = urlParams.get('timer') === 'true';
            settings.sound = urlParams.get('sound') === 'true';
            settings.music = urlParams.get('music') === 'true';
            
            console.log('‚è±Ô∏è Timer enabled:', settings.timer);
            console.log('üîä Sound enabled:', settings.sound);
            console.log('üéµ Music enabled:', settings.music);
            
            // Validation check
            if (!playerParam) {
                console.warn('‚ö†Ô∏è No player name in URL, using default');
            }
            if (!difficultyParam || !validDifficulties.includes(difficultyParam)) {
                console.warn('‚ö†Ô∏è Invalid/missing difficulty in URL, using easy');
            }
            
            console.log('‚úÖ Final settings loaded:', settings);
            
            // Update UI immediately
            updateGameHeader();
        }
        
        function updateGameHeader() {
            // Update player name in header
            gamePlayerName.textContent = displayName;
            
            // Update settings display
            const difficultyText = {
                'easy': '‡∫á‡ªà‡∫≤‡∫ç',
                'medium': '‡∫õ‡∫≤‡∫ô‡∫Å‡∫≤‡∫á', 
                'hard': '‡∫ç‡∫≤‡∫Å'
            }[settings.difficulty];
            
            const timerText = settings.timer ? '‡ªÄ‡∫õ‡∫µ‡∫î (5 ‡∫ß‡∫¥)' : '‡∫õ‡∫¥‡∫î';
            gameSettingsDisplay.textContent = `Difficulty: ${difficultyText} | Timer: ${timerText}`;
            
            console.log('üéØ Game header updated with player:', displayName, 'settings:', settings);
        }

        // Event Listeners
        document.getElementById('back-to-menu-btn').addEventListener('click', backToMenu);

        wordCardLeft.addEventListener('click', () => handleSelection('left'));
        wordCardRight.addEventListener('click', () => handleSelection('right'));

        document.addEventListener('keydown', (e) => {
            if (!gameInProgress) return;
            
            if (e.key.toLowerCase() === 'a') {
                wordCardLeft.classList.add('focused');
                handleSelection('left');
            } else if (e.key.toLowerCase() === 'd') {
                wordCardRight.classList.add('focused');
                handleSelection('right');
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key.toLowerCase() === 'a') wordCardLeft.classList.remove('focused');
            if (e.key.toLowerCase() === 'd') wordCardRight.classList.remove('focused');
        });

                 // Initialization
         window.onload = async () => {
             // Get parameters from URL
             getURLParameters();
             
             // Initialize DOM references
             heartsContainer = document.querySelector('.hearts');
             motivationText = document.querySelector('.motivation-text');
             
             // Initialize background music
             initializeBackgroundMusic();
             
             // Load user data
             loadUserData();
             
             // Load word lists with error handling
             try {
                 await loadWordListsFromGoogleSheets();
             } catch (error) {
                 console.warn("Google Sheets loading failed, continuing with fallback data:", error);
                 // Don't redirect - fallback data is handled in loadWordListsFromGoogleSheets()
             }
             
             // Initialize personal records display
             updatePersonalRecordsDisplay();
             
             // Set up game
             gamePlayerName.textContent = displayName;
             bestStreakEl.textContent = stats.bestStreak;
             currentStreak = 0;
             gameInProgress = true;
             resetLives();
             
             // Start background music if enabled
             toggleBackgroundMusic();
             
             // Start first round
             nextRound();
         };
    </script>
</body>
</html>
